{
    "sourceFile": "authorization-api/adapters/drivens/authorization_driven_adapter.go",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 2,
            "patches": [
                {
                    "date": 1719212814842,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1719213674059,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,75 +0,0 @@\n-package drivens\r\n-\r\n-import (\r\n-    \"context\"\r\n-    \"errors\"\r\n-    \"authorization-api/models\"\r\n-    \"encoding/json\"\r\n-    \"io/ioutil\"\r\n-)\r\n-\r\n-type AuthorizationRule struct {\r\n-    Rol      string `json:\"rol\"`\r\n-    Resource string `json:\"resource\"`\r\n-    Action   string `json:\"action\"`\r\n-}\r\n-\r\n-type AuthorizationAdapter struct {\r\n-    rules []AuthorizationRule\r\n-}\r\n-\r\n-func NewAuthorizationAdapter() *AuthorizationAdapter {\r\n-    // Cargar reglas de autorización desde un archivo mock\r\n-    rules, err := loadMockRules(\"authorization_rules_mock.json\")\r\n-    if err != nil {\r\n-        panic(err)\r\n-    }\r\n-\r\n-    return &AuthorizationAdapter{\r\n-        rules: rules,\r\n-    }\r\n-}\r\n-\r\n-func (aa *AuthorizationAdapter) Authorize(ctx context.Context, token string, resource string, action string) (bool, error) {\r\n-    // Decodificar el token para obtener el rol del usuario\r\n-    claims, err := parseToken(token)\r\n-    if err != nil {\r\n-        return false, err\r\n-    }\r\n-\r\n-    userRol := claims[\"rol\"].(string)\r\n-\r\n-    // Verificar las reglas de autorización\r\n-    for _, rule := range aa.rules {\r\n-        if rule.Rol == userRol && rule.Resource == resource && rule.Action == action {\r\n-            return true, nil\r\n-        }\r\n-    }\r\n-\r\n-    return false, errors.New(\"not authorized\")\r\n-}\r\n-\r\n-func loadMockRules(filename string) ([]AuthorizationRule, error) {\r\n-    data, err := ioutil.ReadFile(filename)\r\n-    if err != nil {\r\n-        return nil, err\r\n-    }\r\n-\r\n-    var rules []AuthorizationRule\r\n-    if err := json.Unmarshal(data, &rules); err != nil {\r\n-        return nil, err\r\n-    }\r\n-\r\n-    return rules, nil\r\n-}\r\n-\r\n-func parseToken(token string) (map[string]interface{}, error) {\r\n-    // Esta función debe decodificar el token JWT y devolver los claims\r\n-    // Aquí estamos asumiendo que el token es simplemente un JSON codificado en base64\r\n-    var claims map[string]interface{}\r\n-    // Decodificar el token (esto es solo un ejemplo, en producción se debe usar una librería JWT)\r\n-    if err := json.Unmarshal([]byte(token), &claims); err != nil {\r\n-        return nil, err\r\n-    }\r\n-    return claims, nil\r\n-}\r\n\\ No newline at end of file\n"
                },
                {
                    "date": 1719216240279,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,5 +1,5 @@\n-package drivens\r\n+package ad\r\n \r\n import (\r\n     \"context\"\r\n     \"errors\"\r\n"
                }
            ],
            "date": 1719212814842,
            "name": "Commit-0",
            "content": ""
        }
    ]
}