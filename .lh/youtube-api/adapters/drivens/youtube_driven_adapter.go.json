{
    "sourceFile": "youtube-api/adapters/drivens/youtube_driven_adapter.go",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 6,
            "patches": [
                {
                    "date": 1719192647518,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1719193140621,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,77 @@\n+package drivens\r\n+\r\n+import (\r\n+    \"encoding/json\"\r\n+    \"fmt\"\r\n+    \"models\"\r\n+    \"os\"\r\n+    \"time\"\r\n+)\r\n+\r\n+type MonitorAdapter struct{}\r\n+\r\n+func NewMonitorAdapter() *MonitorAdapter {\r\n+    return &MonitorAdapter{}\r\n+}\r\n+\r\n+func (ma *MonitorAdapter) SaveMonitorLog(log models.MonitorLog) error {\r\n+    log.Fecha = time.Now().Format(\"2006-01-02\")\r\n+    log.Hora = time.Now().Format(\"15_04_05\")\r\n+    filename := fmt.Sprintf(\"monitor/monitor-%s-%s.json\", log.Fecha, log.Hora)\r\n+\r\n+    if _, err := os.Stat(\"monitor\"); os.IsNotExist(err) {\r\n+        err := os.Mkdir(\"monitor\", os.ModePerm)\r\n+        if err != nil {\r\n+            return fmt.Errorf(\"failed to create monitor directory: %v\", err)\r\n+        }\r\n+    }\r\n+\r\n+    file, err := os.Create(filename)\r\n+    if err != nil {\r\n+        return err\r\n+    }\r\n+    defer file.Close()\r\n+\r\n+    encoder := json.NewEncoder(file)\r\n+    err = encoder.Encode(log)\r\n+    if err != nil {\r\n+        return err\r\n+    }\r\n+\r\n+    fmt.Println(\"Archivo de monitorización ha sido generado y guardado:\", filename)\r\n+    return nil\r\n+}\r\n+\r\n+type ErrorAdapter struct{}\r\n+\r\n+func NewErrorAdapter() *ErrorAdapter {\r\n+    return &ErrorAdapter{}\r\n+}\r\n+\r\n+func (ea *ErrorAdapter) SaveErrorLog(log models.ErrorLog) error {\r\n+    log.Fecha = time.Now().Format(\"2006-01-02\")\r\n+    log.Hora = time.Now().Format(\"15_04_05\")\r\n+    filename := fmt.Sprintf(\"logs/log-%s-%s.json\", log.Fecha, log.Hora)\r\n+\r\n+    if _, err := os.Stat(\"logs\"); os.IsNotExist(err) {\r\n+        err := os.Mkdir(\"logs\", os.ModePerm)\r\n+        if err != nil {\r\n+            return fmt.Errorf(\"failed to create logs directory: %v\", err)\r\n+        }\r\n+    }\r\n+\r\n+    file, err := os.Create(filename)\r\n+    if err != nil {\r\n+        return err\r\n+    }\r\n+    defer file.Close()\r\n+\r\n+    encoder := json.NewEncoder(file)\r\n+    err = encoder.Encode(log)\r\n+    if err != nil {\r\n+        return err\r\n+    }\r\n+\r\n+    fmt.Println(\"Archivo de log ha sido generado y guardado:\", filename)\r\n+    return nil\r\n+}\r\n"
                },
                {
                    "date": 1719202222275,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,25 @@\n+package drivens\r\n+\r\n+import (\r\n+    \"context\"\r\n+    \"google.golang.org/api/youtube/v3\"\r\n+    \"youtube-api/models\"\r\n+    \"youtube-api/ports/drivens\"\r\n+)\r\n+\r\n+type YouTubeAdapter struct {\r\n+    service *youtube.Service\r\n+}\r\n+\r\n+func NewYouTubeAdapter() (*YouTubeAdapter, error) {\r\n+    // Initialize YouTube service\r\n+    // ...\r\n+    return &YouTubeAdapter{\r\n+        service: service,\r\n+    }, nil\r\n+}\r\n+\r\n+func (yt *YouTubeAdapter) GetSearching(ctx context.Context, query string) ([]models.DataYT, error) {\r\n+    // Implementación para obtener resultados de búsqueda de YouTube\r\n+    // ...\r\n+}\r\n"
                },
                {
                    "date": 1719203963829,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,169 @@\n+package drivens\r\n+\r\n+import (\r\n+    \"context\"\r\n+    \"fmt\"\r\n+    \"google.golang.org/api/option\"\r\n+    \"google.golang.org/api/youtube/v3\"\r\n+    \"os\"\r\n+    \"strings\"\r\n+    \"youtube-api/models\"\r\n+)\r\n+\r\n+type YouTubeAdapter struct {\r\n+    service      *youtube.Service\r\n+    apiKey       string\r\n+    channelIDs   []string\r\n+    maxResults   int64\r\n+}\r\n+\r\n+func NewYouTubeAdapter() (*YouTubeAdapter, error) {\r\n+    apiKey := os.Getenv(\"YOUTUBE_API_KEY\")\r\n+    if apiKey == \"\" {\r\n+        return nil, fmt.Errorf(\"missing YOUTUBE_API_KEY environment variable\")\r\n+    }\r\n+\r\n+    channelIDs := strings.Split(os.Getenv(\"YOUTUBE_CHANNEL_ID\"), \",\")\r\n+    if len(channelIDs) == 0 {\r\n+        return nil, fmt.Errorf(\"missing YOUTUBE_CHANNEL_ID environment variable\")\r\n+    }\r\n+\r\n+    maxResults := os.Getenv(\"YOUTUBE_MAX_RESULTS\")\r\n+    if maxResults == \"\" {\r\n+        return nil, fmt.Errorf(\"missing YOUTUBE_MAX_RESULTS environment variable\")\r\n+    }\r\n+\r\n+    ctx := context.Background()\r\n+    service, err := youtube.NewService(ctx, option.WithAPIKey(apiKey))\r\n+    if err != nil {\r\n+        return nil, err\r\n+    }\r\n+\r\n+    return &YouTubeAdapter{\r\n+        service:    service,\r\n+        apiKey:     apiKey,\r\n+        channelIDs: channelIDs,\r\n+        maxResults: maxResults,\r\n+    }, nil\r\n+}\r\n+\r\n+func (yt *YouTubeAdapter) GetSearching(ctx context.Context, query string) ([]models.DataYT, error) {\r\n+    var results []models.DataYT\r\n+    for _, channelID := range yt.channelIDs {\r\n+        call := yt.service.Search.List([]string{\"id\", \"snippet\"}).\r\n+            Q(query).\r\n+            ChannelId(channelID).\r\n+            MaxResults(yt.maxResults)\r\n+\r\n+        response, err := call.Do()\r\n+        if err != nil {\r\n+            return nil, err\r\n+        }\r\n+\r\n+        for _, item := range response.Items {\r\n+            results = append(results, models.DataYT{\r\n+                ID:          item.Id.VideoId,\r\n+                Title:       item.Snippet.Title,\r\n+                Description: item.Snippet.Description,\r\n+                URL:         \"https://www.youtube.com/watch?v=\" + item.Id.VideoId,\r\n+            })\r\n+        }\r\n+    }\r\n+    return results, nil\r\n+}\r\n+\r\n+func (yt *YouTubeAdapter) GetRandomVideo(ctx context.Context) (models.DataYT, error) {\r\n+    for _, channelID := range yt.channelIDs {\r\n+        call := yt.service.Search.List([]string{\"id\", \"snippet\"}).\r\n+            ChannelId(channelID).\r\n+            MaxResults(1)\r\n+\r\n+        response, err := call.Do()\r\n+        if err != nil {\r\n+            return models.DataYT{}, err\r\n+        }\r\n+\r\n+        if len(response.Items) > 0 {\r\n+            item := response.Items[0]\r\n+            return models.DataYT{\r\n+                ID:          item.Id.VideoId,\r\n+                Title:       item.Snippet.Title,\r\n+                Description: item.Snippet.Description,\r\n+                URL:         \"https://www.youtube.com/watch?v=\" + item.Id.VideoId,\r\n+            }, nil\r\n+        }\r\n+    }\r\n+    return models.DataYT{}, fmt.Errorf(\"no videos found\")\r\n+}\r\n+\r\n+func (yt *YouTubeAdapter) GetSearchPlaylists(ctx context.Context) ([]models.DataYT, error) {\r\n+    var results []models.DataYT\r\n+    for _, channelID := range yt.channelIDs {\r\n+        call := yt.service.Playlists.List([]string{\"id\", \"snippet\"}).\r\n+            ChannelId(channelID).\r\n+            MaxResults(yt.maxResults)\r\n+\r\n+        response, err := call.Do()\r\n+        if err != nil {\r\n+            return nil, err\r\n+        }\r\n+\r\n+        for _, item := range response.Items {\r\n+            results = append(results, models.DataYT{\r\n+                ID:          item.Id,\r\n+                Title:       item.Snippet.Title,\r\n+                Description: item.Snippet.Description,\r\n+                URL:         \"https://www.youtube.com/playlist?list=\" + item.Id,\r\n+            })\r\n+        }\r\n+    }\r\n+    return results, nil\r\n+}\r\n+\r\n+func (yt *YouTubeAdapter) GetSearchPlaylistsItems(ctx context.Context, playlistID string) ([]models.DataYT, error) {\r\n+    call := yt.service.PlaylistItems.List([]string{\"id\", \"snippet\"}).\r\n+        PlaylistId(playlistID).\r\n+        MaxResults(yt.maxResults)\r\n+\r\n+    response, err := call.Do()\r\n+    if err != nil {\r\n+        return nil, err\r\n+    }\r\n+\r\n+    var results []models.DataYT\r\n+    for _, item := range response.Items {\r\n+        results = append(results, models.DataYT{\r\n+            ID:          item.Snippet.ResourceId.VideoId,\r\n+            Title:       item.Snippet.Title,\r\n+            Description: item.Snippet.Description,\r\n+            URL:         \"https://www.youtube.com/watch?v=\" + item.Snippet.ResourceId.VideoId,\r\n+        })\r\n+    }\r\n+    return results, nil\r\n+}\r\n+\r\n+func (yt *YouTubeAdapter) GetCheckLive(ctx context.Context) (models.DataYT, error) {\r\n+    for _, channelID := range yt.channelIDs {\r\n+        call := yt.service.LiveBroadcasts.List([]string{\"id\", \"snippet\", \"contentDetails\", \"status\"}).\r\n+            ChannelId(channelID).\r\n+            BroadcastStatus(\"active\").\r\n+            BroadcastType(\"all\").\r\n+            MaxResults(yt.maxResults)\r\n+\r\n+        response, err := call.Do()\r\n+        if err != nil {\r\n+            return models.DataYT{}, err\r\n+        }\r\n+\r\n+        if len(response.Items) > 0 {\r\n+            item := response.Items[0]\r\n+            return models.DataYT{\r\n+                ID:          item.Id,\r\n+                Title:       item.Snippet.Title,\r\n+                Description: \"Live now\",\r\n+                URL:         \"https://www.youtube.com/watch?v=\" + item.Id,\r\n+            }, nil\r\n+        }\r\n+    }\r\n+    return models.DataYT{}, fmt.Errorf(\"no live broadcasts found\")\r\n+}\r\n"
                },
                {
                    "date": 1719204343964,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -141,9 +141,9 @@\n     }\r\n     return results, nil\r\n }\r\n \r\n-func (yt *YouTubeAdapter) GetCheckLive(ctx context.Context) (models.DataYT, error) {\r\n+func (yt *YouTubeAdapter) YOUTUBE_CHANNEL_ID(ctx context.Context) (models.DataYT, error) {\r\n     for _, channelID := range yt.channelIDs {\r\n         call := yt.service.LiveBroadcasts.List([]string{\"id\", \"snippet\", \"contentDetails\", \"status\"}).\r\n             ChannelId(channelID).\r\n             BroadcastStatus(\"active\").\r\n"
                },
                {
                    "date": 1719204731976,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,18 +4,21 @@\n     \"context\"\r\n     \"fmt\"\r\n     \"google.golang.org/api/option\"\r\n     \"google.golang.org/api/youtube/v3\"\r\n+    \"math/rand\"\r\n     \"os\"\r\n     \"strings\"\r\n+    \"time\"\r\n     \"youtube-api/models\"\r\n )\r\n \r\n type YouTubeAdapter struct {\r\n     service      *youtube.Service\r\n     apiKey       string\r\n     channelIDs   []string\r\n     maxResults   int64\r\n+    vodChannelID string\r\n }\r\n \r\n func NewYouTubeAdapter() (*YouTubeAdapter, error) {\r\n     apiKey := os.Getenv(\"YOUTUBE_API_KEY\")\r\n@@ -27,24 +30,30 @@\n     if len(channelIDs) == 0 {\r\n         return nil, fmt.Errorf(\"missing YOUTUBE_CHANNEL_ID environment variable\")\r\n     }\r\n \r\n-    maxResults := os.Getenv(\"YOUTUBE_MAX_RESULTS\")\r\n-    if maxResults == \"\" {\r\n-        return nil, fmt.Errorf(\"missing YOUTUBE_MAX_RESULTS environment variable\")\r\n+    maxResults, err := strconv.ParseInt(os.Getenv(\"YOUTUBE_MAX_RESULTS\"), 10, 64)\r\n+    if err != nil {\r\n+        return nil, fmt.Errorf(\"invalid YOUTUBE_MAX_RESULTS environment variable\")\r\n     }\r\n \r\n+    vodChannelID := os.Getenv(\"YOUTUBE_CHANNEL_ID_GP_VODS\")\r\n+    if vodChannelID == \"\" {\r\n+        return nil, fmt.Errorf(\"missing YOUTUBE_CHANNEL_ID_GP_VODS environment variable\")\r\n+    }\r\n+\r\n     ctx := context.Background()\r\n     service, err := youtube.NewService(ctx, option.WithAPIKey(apiKey))\r\n     if err != nil {\r\n         return nil, err\r\n     }\r\n \r\n     return &YouTubeAdapter{\r\n-        service:    service,\r\n-        apiKey:     apiKey,\r\n-        channelIDs: channelIDs,\r\n-        maxResults: maxResults,\r\n+        service:      service,\r\n+        apiKey:       apiKey,\r\n+        channelIDs:   channelIDs,\r\n+        maxResults:   maxResults,\r\n+        vodChannelID: vodChannelID,\r\n     }, nil\r\n }\r\n \r\n func (yt *YouTubeAdapter) GetSearching(ctx context.Context, query string) ([]models.DataYT, error) {\r\n@@ -72,20 +81,22 @@\n     return results, nil\r\n }\r\n \r\n func (yt *YouTubeAdapter) GetRandomVideo(ctx context.Context) (models.DataYT, error) {\r\n+    rand.Seed(time.Now().UnixNano())\r\n     for _, channelID := range yt.channelIDs {\r\n         call := yt.service.Search.List([]string{\"id\", \"snippet\"}).\r\n             ChannelId(channelID).\r\n-            MaxResults(1)\r\n+            MaxResults(yt.maxResults)\r\n \r\n         response, err := call.Do()\r\n         if err != nil {\r\n             return models.DataYT{}, err\r\n         }\r\n \r\n         if len(response.Items) > 0 {\r\n-            item := response.Items[0]\r\n+            randomIndex := rand.Intn(len(response.Items))\r\n+            item := response.Items[randomIndex]\r\n             return models.DataYT{\r\n                 ID:          item.Id.VideoId,\r\n                 Title:       item.Snippet.Title,\r\n                 Description: item.Snippet.Description,\r\n@@ -142,28 +153,31 @@\n     return results, nil\r\n }\r\n \r\n func (yt *YouTubeAdapter) GetCheckLive(ctx context.Context) (models.DataYT, error) {\r\n-    for _, channelID := range yt.channelIDs {\r\n-        call := yt.service.LiveBroadcasts.List([]string{\"id\", \"snippet\", \"contentDetails\", \"status\"}).\r\n-            ChannelId(channelID).\r\n-            BroadcastStatus(\"active\").\r\n-            BroadcastType(\"all\").\r\n-            MaxResults(yt.maxResults)\r\n+    call := yt.service.LiveBroadcasts.List([]string{\"id\", \"snippet\", \"contentDetails\", \"status\"}).\r\n+        ChannelId(yt.vodChannelID).\r\n+        BroadcastStatus(\"active\").\r\n+        BroadcastType(\"all\").\r\n+        MaxResults(yt.maxResults)\r\n \r\n-        response, err := call.Do()\r\n-        if err != nil {\r\n-            return models.DataYT{}, err\r\n-        }\r\n+    response, err := call.Do()\r\n+    if err != nil {\r\n+        return models.DataYT{}, err\r\n+    }\r\n \r\n-        if len(response.Items) > 0 {\r\n-            item := response.Items[0]\r\n-            return models.DataYT{\r\n-                ID:          item.Id,\r\n-                Title:       item.Snippet.Title,\r\n-                Description: \"Live now\",\r\n-                URL:         \"https://www.youtube.com/watch?v=\" + item.Id,\r\n-            }, nil\r\n-        }\r\n+    if len(response.Items) > 0 {\r\n+        item := response.Items[0]\r\n+        return models.DataYT{\r\n+            ID:          item.Id,\r\n+            Title:       item.Snippet.Title,\r\n+            Description: \"Live now\",\r\n+            URL:         \"https://www.youtube.com/watch?v=\" + item.Id,\r\n+        }, nil\r\n     }\r\n-    return models.DataYT{}, fmt.Errorf(\"no live broadcasts found\")\r\n+    return models.DataYT{\r\n+        ID:          \"\",\r\n+        Title:       \"\",\r\n+        Description: \"No live broadcasts found\",\r\n+        URL:         \"\",\r\n+    }, nil\r\n }\r\n"
                },
                {
                    "date": 1719205059248,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,184 @@\n+package drivens\r\n+\r\n+import (\r\n+    \"context\"\r\n+    \"fmt\"\r\n+    \"google.golang.org/api/option\"\r\n+    \"google.golang.org/api/youtube/v3\"\r\n+    \"math/rand\"\r\n+    \"os\"\r\n+    \"strconv\"\r\n+    \"strings\"\r\n+    \"time\"\r\n+    \"youtube-api/models\"\r\n+)\r\n+\r\n+type YouTubeAdapter struct {\r\n+    service      *youtube.Service\r\n+    apiKey       string\r\n+    channelIDs   []string\r\n+    maxResults   int64\r\n+    vodChannelID string\r\n+}\r\n+\r\n+func NewYouTubeAdapter() (*YouTubeAdapter, error) {\r\n+    apiKey := os.Getenv(\"YOUTUBE_API_KEY\")\r\n+    if apiKey == \"\" {\r\n+        return nil, fmt.Errorf(\"missing YOUTUBE_API_KEY environment variable\")\r\n+    }\r\n+\r\n+    channelIDs := strings.Split(os.Getenv(\"YOUTUBE_CHANNEL_ID\"), \",\")\r\n+    if len(channelIDs) == 0 {\r\n+        return nil, fmt.Errorf(\"missing YOUTUBE_CHANNEL_ID environment variable\")\r\n+    }\r\n+\r\n+    maxResults, err := strconv.ParseInt(os.Getenv(\"YOUTUBE_MAX_RESULTS\"), 10, 64)\r\n+    if err != nil {\r\n+        return nil, fmt.Errorf(\"invalid YOUTUBE_MAX_RESULTS environment variable\")\r\n+    }\r\n+\r\n+    vodChannelID := os.Getenv(\"YOUTUBE_CHANNEL_ID_GP_VODS\")\r\n+    if vodChannelID == \"\" {\r\n+        return nil, fmt.Errorf(\"missing YOUTUBE_CHANNEL_ID_GP_VODS environment variable\")\r\n+    }\r\n+\r\n+    ctx := context.Background()\r\n+    service, err := youtube.NewService(ctx, option.WithAPIKey(apiKey))\r\n+    if err != nil {\r\n+        return nil, err\r\n+    }\r\n+\r\n+    return &YouTubeAdapter{\r\n+        service:      service,\r\n+        apiKey:       apiKey,\r\n+        channelIDs:   channelIDs,\r\n+        maxResults:   maxResults,\r\n+        vodChannelID: vodChannelID,\r\n+    }, nil\r\n+}\r\n+\r\n+func (yt *YouTubeAdapter) GetSearching(ctx context.Context, query string) ([]models.DataYT, error) {\r\n+    var results []models.DataYT\r\n+    for _, channelID := range yt.channelIDs {\r\n+        call := yt.service.Search.List([]string{\"id\", \"snippet\"}).\r\n+            Q(query).\r\n+            ChannelId(channelID).\r\n+            MaxResults(yt.maxResults)\r\n+\r\n+        response, err := call.Do()\r\n+        if err != nil {\r\n+            return nil, err\r\n+        }\r\n+\r\n+        for _, item := range response.Items {\r\n+            results = append(results, models.DataYT{\r\n+                ID:          item.Id.VideoId,\r\n+                Title:       item.Snippet.Title,\r\n+                Description: item.Snippet.Description,\r\n+                URL:         \"https://www.youtube.com/watch?v=\" + item.Id.VideoId,\r\n+            })\r\n+        }\r\n+    }\r\n+    return results, nil\r\n+}\r\n+\r\n+func (yt *YouTubeAdapter) GetRandomVideo(ctx context.Context) (models.DataYT, error) {\r\n+    rand.Seed(time.Now().UnixNano())\r\n+    for _, channelID := range yt.channelIDs {\r\n+        call := yt.service.Search.List([]string{\"id\", \"snippet\"}).\r\n+            ChannelId(channelID).\r\n+            MaxResults(yt.maxResults)\r\n+\r\n+        response, err := call.Do()\r\n+        if err != nil {\r\n+            return models.DataYT{}, err\r\n+        }\r\n+\r\n+        if len(response.Items) > 0 {\r\n+            randomIndex := rand.Intn(len(response.Items))\r\n+            item := response.Items[randomIndex]\r\n+            return models.DataYT{\r\n+                ID:          item.Id.VideoId,\r\n+                Title:       item.Snippet.Title,\r\n+                Description: item.Snippet.Description,\r\n+                URL:         \"https://www.youtube.com/watch?v=\" + item.Id.VideoId,\r\n+            }, nil\r\n+        }\r\n+    }\r\n+    return models.DataYT{}, fmt.Errorf(\"no videos found\")\r\n+}\r\n+\r\n+func (yt *YouTubeAdapter) GetSearchPlaylists(ctx context.Context) ([]models.DataYT, error) {\r\n+    var results []models.DataYT\r\n+    for _, channelID := range yt.channelIDs {\r\n+        call := yt.service.Playlists.List([]string{\"id\", \"snippet\"}).\r\n+            ChannelId(channelID).\r\n+            MaxResults(yt.maxResults)\r\n+\r\n+        response, err := call.Do()\r\n+        if err != nil {\r\n+            return nil, err\r\n+        }\r\n+\r\n+        for _, item := range response.Items {\r\n+            results = append(results, models.DataYT{\r\n+                ID:          item.Id,\r\n+                Title:       item.Snippet.Title,\r\n+                Description: item.Snippet.Description,\r\n+                URL:         \"https://www.youtube.com/playlist?list=\" + item.Id,\r\n+            })\r\n+        }\r\n+    }\r\n+    return results, nil\r\n+}\r\n+\r\n+func (yt *YouTubeAdapter) GetSearchPlaylistsItems(ctx context.Context, playlistID string) ([]models.DataYT, error) {\r\n+    call := yt.service.PlaylistItems.List([]string{\"id\", \"snippet\"}).\r\n+        PlaylistId(playlistID).\r\n+        MaxResults(yt.maxResults)\r\n+\r\n+    response, err := call.Do()\r\n+    if err != nil {\r\n+        return nil, err\r\n+    }\r\n+\r\n+    var results []models.DataYT\r\n+    for _, item := range response.Items {\r\n+        results = append(results, models.DataYT{\r\n+            ID:          item.Snippet.ResourceId.VideoId,\r\n+            Title:       item.Snippet.Title,\r\n+            Description: item.Snippet.Description,\r\n+            URL:         \"https://www.youtube.com/watch?v=\" + item.Snippet.ResourceId.VideoId,\r\n+        })\r\n+    }\r\n+    return results, nil\r\n+}\r\n+\r\n+func (yt *YouTubeAdapter) GetCheckLive(ctx context.Context) (models.DataYT, error) {\r\n+    call := yt.service.LiveBroadcasts.List([]string{\"id\", \"snippet\", \"contentDetails\", \"status\"}).\r\n+        ChannelId(yt.vodChannelID).\r\n+        BroadcastStatus(\"active\").\r\n+        BroadcastType(\"all\").\r\n+        MaxResults(yt.maxResults)\r\n+\r\n+    response, err := call.Do()\r\n+    if err != nil {\r\n+        return models.DataYT{}, err\r\n+    }\r\n+\r\n+    if len(response.Items) > 0 {\r\n+        item := response.Items[0]\r\n+        return models.DataYT{\r\n+            ID:          item.Id,\r\n+            Title:       item.Snippet.Title,\r\n+            Description: \"Live now\",\r\n+            URL:         \"https://www.youtube.com/watch?v=\" + item.Id,\r\n+        }, nil\r\n+    }\r\n+    return models.DataYT{\r\n+        ID:          \"\",\r\n+        Title:       \"\",\r\n+        Description: \"No live broadcasts found\",\r\n+        URL:         \"\",\r\n+    }, nil\r\n+}\r\n"
                }
            ],
            "date": 1719192647518,
            "name": "Commit-0",
            "content": "package drivens\r\n\r\nimport (\r\n    \"encoding/json\"\r\n    \"fmt\"\r\n    \"models\"\r\n    \"os\"\r\n    \"time\"\r\n)\r\n\r\ntype MonitorAdapter struct{}\r\n\r\nfunc NewMonitorAdapter() *MonitorAdapter {\r\n    return &MonitorAdapter{}\r\n}\r\n\r\nfunc (ma *MonitorAdapter) SaveMonitorLog(log models.MonitorLog) error {\r\n    log.Fecha = time.Now().Format(\"2006-01-02\")\r\n    log.Hora = time.Now().Format(\"15_04_05\")\r\n    filename := fmt.Sprintf(\"monitor/monitor-%s-%s.json\", log.Fecha, log.Hora)\r\n\r\n    if _, err := os.Stat(\"monitor\"); os.IsNotExist(err) {\r\n        err := os.Mkdir(\"monitor\", os.ModePerm)\r\n        if err != nil {\r\n            return fmt.Errorf(\"failed to create monitor directory: %v\", err)\r\n        }\r\n    }\r\n\r\n    file, err := os.Create(filename)\r\n    if err != nil {\r\n        return err\r\n    }\r\n    defer file.Close()\r\n\r\n    encoder := json.NewEncoder(file)\r\n    err = encoder.Encode(log)\r\n    if err != nil {\r\n        return err\r\n    }\r\n\r\n    fmt.Println(\"Archivo de monitorización ha sido generado y guardado:\", filename)\r\n    return nil\r\n}\r\n\r\ntype ErrorAdapter struct{}\r\n\r\nfunc NewErrorAdapter() *ErrorAdapter {\r\n    return &ErrorAdapter{}\r\n}\r\n\r\nfunc (ea *ErrorAdapter) SaveErrorLog(log models.ErrorLog) error {\r\n    log.Fecha = time.Now().Format(\"2006-01-02\")\r\n    log.Hora = time.Now().Format(\"15_04_05\")\r\n    filename := fmt.Sprintf(\"logs/log-%s-%s.json\", log.Fecha, log.Hora)\r\n\r\n    if _, err := os.Stat(\"logs\"); os.IsNotExist(err) {\r\n        err := os.Mkdir(\"logs\", os.ModePerm)\r\n        if err != nil {\r\n            return fmt.Errorf(\"failed to create logs directory: %v\", err)\r\n        }\r\n    }\r\n\r\n    file, err := os.Create(filename)\r\n    if err != nil {\r\n        return err\r\n    }\r\n    defer file.Close()\r\n\r\n    encoder := json.NewEncoder(file)\r\n    err = encoder.Encode(log)\r\n    if err != nil {\r\n        return err\r\n    }\r\n\r\n    fmt.Println(\"Archivo de log ha sido generado y guardado:\", filename)\r\n    return nil\r\n}\r\n"
        }
    ]
}